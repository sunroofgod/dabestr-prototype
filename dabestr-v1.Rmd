---
title: "dabestr-v1"
output: html_document
date: '2023-06-24'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(stringr)
library(lubridate)
library(cowplot)
library(rlang)
library(magrittr)
library(ggbeeswarm)
library(boot)
library(effsize)
library(grid)
library(scales)
```

# load function
```{r}
load <- function(
    data,
    x = NULL,
    y = NULL,
    idx = NULL,
    is_paired = FALSE,
    id_col = NULL,
    ci = 95,
    colour = NULL,
    proportional = FALSE
    ){
  
  # Storing plotting params as quosures
  enquo_x <- enquo(x)
  enquo_y <- enquo(y)
  enquo_id_col <- enquo(id_col)
  enquo_colour <- enquo(colour)
  
  name_x <- as_name(enquo_x)
  name_y <- as_name(enquo_y)
  
  if (!is.null(idx)){
    raw_data <- data %>%
      filter(!!enquo_x %in% idx) %>%
      
      # (to be changed later for multi-group)
      mutate(x_axis_raw = case_when(
        Group == idx[1] ~ 1,
        Group == idx[2] ~ 2,
      )) 
    
    # Obtain raw_y_range_vector
    ylim <- range(raw_data[[name_y]])
    
    # Creation of x-axis label
    Ns <- raw_data %>%
      dplyr::group_by(!!enquo_x) %>%
      dplyr::count()
    Ns$swarmticklabs <- do.call(paste, c(Ns[c(name_x, "n")], sep = "\nN = "))
    
    # (to be changed later for multi-group)
    buffer_Ns <- data.frame(Group = "", n = 0, swarmticklabs = "") 
    Ns <- rbind(Ns)
    
    if(isTRUE(proportional)){
      ## include checks here for data to see if it is proportional data
      proportional_data <- raw_data %>%
        select(!!enquo_x, !!enquo_y, !!enquo_id_col, !!enquo_colour) %>%
        group_by(!!enquo_x) %>%
        summarise(proportion_success = mean(!!enquo_y),
                  y_success = proportion_success/2,
                  y_failure = (1+proportion_success)/2)
      
      control_summary <- proportional_data$proportion_success[1]
      test_summary <- proportional_data$proportion_success[2]
        
    } else {
      # Extending ylim for geom_beeswarm points being plotted
      ylim[1] <- ylim[1] - (ylim[2]-ylim[1])/10
      ylim[2] <- ylim[2] + (ylim[2]-ylim[1])/10
      
      # Calculation of summary lines
      summaries <- raw_data %>%
        group_by(!!enquo_x) %>%
        summarise(summary_stats = mean(!!enquo_y))
      
      control_summary <- summaries$summary_stats[1]
      test_summary <- summaries$summary_stats[2]
      
      proportional_data <- NULL
    }
    
    dabest_object <- list(
      raw_data = raw_data,
      proportional_data = proportional_data,
      enquo_x = enquo_x,
      enquo_y = enquo_y,
      enquo_id_col = enquo_id_col,
      enquo_colour = enquo_colour,
      proportional = proportional,
      idx = idx,
      is_paired = is_paired,
      ci = ci,
      Ns = Ns,
      control_summary = control_summary,
      test_summary = test_summary,
      ylim = ylim
    )
    
    class(dabest_object) <- c("dabest")
    
    return(dabest_object)
  }
  stop()
}
```

# Bootstrap helper functions
```{r}
effsize_boot <- function(
    data, 
    effect_size_func, 
    reps = 5000, 
    paired = FALSE
    ){
  
  s <- c(rep(1, length(data$control)),
         rep(2, length(data$test)))

  bootboot <- function(d, indices, paired) {
    c <- d[indices[s == 1]]
    t <- d[indices[s == 2]]

    return(effect_size_func(c, t, paired))
  }

  b <- boot(
    c(data$control, data$test),
    statistic = bootboot,
    R = reps,
    strata = s,
    paired = paired)

  return(b)
}

bootstrap <- function(
    dabest_obj,
    effect_size_func,
    seed = 12345,
    reps = 5000,
    boot_labs
    ){
  
  result <- tibble()
  
  raw_data <- dabest_obj$raw_data
  idx <- dabest_obj$idx
  idx <- list(idx)
  enquo_x <- dabest_obj$enquo_x
  enquo_y <- dabest_obj$enquo_y
  ci <- dabest_obj$ci
  is_paired <- dabest_obj$is_paired
  
  quoname_x <- as_name(enquo_x)
  quoname_y <- as_name(enquo_y)
  delta_x_labels <- list()
  delta_y_labels <- boot_labs
  
  for(group in idx){
    ctrl_tibble <- raw_data %>% 
      filter(!!enquo_x == !!group[1])
    ctrl_measurement <- ctrl_tibble[[quoname_y]]
    
    test_tibble <- raw_data %>%
      filter(!!enquo_x == !!group[2])
    test_measurement <- test_tibble[[quoname_y]]
    
    xlabels <- paste(group[2],group[1],sep="\nminus\n")
    to_add_xlabels <- c("", xlabels)
    delta_x_labels <- append(delta_x_labels,to_add_xlabels)
    
    control_test_measurement <- list(control = ctrl_measurement,
                                     test = test_measurement)
    set.seed(seed)
    
    boot_result <- effsize_boot(
      data = control_test_measurement,
      effect_size_func = effect_size_func,
      reps=reps,
      paired=is_paired
    )
    
    if (ci < 0 | ci > 100) {
      err_string <- str_interp(
        "`ci` must be between 0 and 100, not ${ci}"
      )
      stop(err_string)
    }
    
    bootci <- boot.ci(boot_result,conf=ci/100,type = c("perc","bca"))
    
    row <- list(
      bootstraps = list(as.vector(boot_result$t)),
      idx = idx,
      delta_x_labels = delta_x_labels,
      delta_y_labels = delta_y_labels,
      row_num = 2,
      bca_ci_low = bootci$bca[4],
      bca_ci_high = bootci$bca[5],
      difference = boot_result$t0,
      raw_data = raw_data,
      is_paired = is_paired,
      Ns = dabest_obj$Ns,
      control_summary = dabest_obj$control_summary,
      test_summary = dabest_obj$test_summary,
      ylim = dabest_obj$ylim,
      enquo_x = dabest_obj$enquo_x,
      enquo_y = dabest_obj$enquo_y,
      enquo_id_col = dabest_obj$enquo_id_col,
      enquo_colour = dabest_obj$enquo_colour,
      proportional = dabest_obj$proportional,
      proportional_data = dabest_obj$proportional_data
    )
  }
  return(row)
}
```

# Main effect_size functions
```{r}
mean_diff <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    if (identical(paired, FALSE)) {
      return(mean(test) - mean(control))
    }
    return(mean(test - control))
  }
  
  is_paired <- dabest_obj$is_paired
  
  if(is_paired){
    return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Paired mean difference"))
  }
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Mean difference"))
}

median_diff <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    if (identical(paired, FALSE)) {
      return(median(test) - median(control))
    }
    return(median(test - control))
  }
  
  is_paired <- dabest_obj$is_paired
  
  if(is_paired){
    return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Paired median difference"))
  }
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Median difference"))
}

cohens_d <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    return(effsize::cohen.d(test, control, paired=paired)$estimate)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cohen's d"))
}

hedges_g <- function(dabest_obj) {
  
  cohens_d_ <- function(control, test, paired) {
    return(effsize::cohen.d(test, control, paired=paired)$estimate)
  }
  
  effect_size_func <- function(control, test, paired) {
    cd <- cohens_d_(test, control, paired=paired)
    corr.factor <- -hedges_correction(test, control)
    return(cd * corr.factor)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Hedges' g"))
}

cliffs_delta <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired=NA) {
    return(effsize::cliff.delta(test, control)$estimate)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cliffs' delta"))
}

cohens_h <- function(dabest_obj){
  
  effect_size_func <- function(control, test, paired) {
    #remove nas and nulls later on
    prop_control <- mean(control)
    prop_test <- mean(test)

    # Arcsine transformation
    phi_control <- 2 * asin(sqrt(prop_control))
    phi_test <- 2 * asin(sqrt(prop_test))
    result <- phi_test - phi_control
    return(result)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cohen's h"))
}

hedges_correction <- function(x1, x2) {

  n1 <- length(x1)
  n2 <- length(x2)

  deg.freedom <- n1 + n2 - 2
  numer       <- gamma(deg.freedom/2)
  denom0      <- gamma((deg.freedom - 1) / 2)
  denom       <- sqrt((deg.freedom / 2)) * denom0

  if (is.infinite(numer) | is.infinite(denom)) {
    # Occurs when df is too large.
    # Applies Hedges and Olkin's approximation.
    df.sum <- n1 + n2
    denom <- (4 * df.sum) - 9
    out <- 1 - (3 / denom)
  } else out <- numer / denom

  return(out)
}
```

# float_contrast/non_float_contrast themes
```{r}
# Theme for left-right graph
float_contrast_theme <- 
  theme(plot.margin = ggplot2::unit(c(5.5, 0, 5.5, 0), "pt"),
        axis.line.x = ggplot2::element_blank(), 
        axis.title.x = ggplot2::element_blank(), 
        axis.ticks.x = ggplot2::element_blank(),
        axis.title.x.bottom = ggplot2::element_blank(),
        legend.position = "left",
        legend.justification = "top",
        legend.title=element_blank())

# Theme for top-down graph
non_float_contrast_theme <- 
  theme(axis.line.x = ggplot2::element_blank(), 
        axis.title.x = ggplot2::element_blank(), 
        axis.ticks.x = ggplot2::element_blank(),
        axis.title.x.bottom = ggplot2::element_blank(),
        axis.title.y = element_text(size = 10),
        legend.position = "left",
        legend.justification = "top",
        legend.title=element_blank())

```

```{r}
# Function for creation of df for tuftelines plot
df_for_tufte <- function(raw_data, enquo_x, enquo_y, proportional){
  tufte_lines_df <- raw_data %>%
    dplyr::group_by(!!enquo_x) %>%
    dplyr::summarize(mean = mean(!!enquo_y),
                     median = median(!!enquo_y),
                     sd = sd(!!enquo_y),
                     lower_quartile = stats::quantile(!!enquo_y)[2],
                     upper_quartile = stats::quantile(!!enquo_y)[4])
  
  if(isTRUE(proportional)){
    tufte_lines_df <- tufte_lines_df %>%
      dplyr::mutate(sd = sd/10)
  }
  tufte_lines_df <- tufte_lines_df %>%
    dplyr::mutate(lower_sd = mean - sd, upper_sd = mean + sd)
  
  return(tufte_lines_df)
}

```

# custom proportionbar geom
```{r}
draw_panel_proportion_bar <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  failure_bar <- rectGrob(x = coords$x,
                          y = coords$yfailure,
                          width = coords$width,
                          height = 1 - coords$proportionsuccess,
                          gp = gpar(col = coords$colour,
                                    fill = "white",
                                    lwd = coords$size * .pt))
  
  success_bar <- rectGrob(x = coords$x,
                          y = coords$ysuccess,
                          width = coords$width,
                          height = coords$proportionsuccess,
                          gp = gpar(col = coords$colour,
                                    fill = alpha(coords$fill, coords$alpha),
                                    lwd = coords$size * .pt))
  
  gTree(children = gList(failure_bar, success_bar))
  
}

GeomProportionBar <- ggproto("GeomProportionBar", Geom,
                      required_aes = c("x", "yfailure", "ysuccess", "proportionsuccess"),
                      default_aes = aes(colour = NA,
                                        width = 0.2,
                                        fill = "grey35",
                                        alpha = NA,
                                        lwd = 2,
                                        size = 0.7),
                      draw_key = draw_key_polygon,
                      draw_panel = draw_panel_proportion_bar)

geom_proportionbar <- function(mapping = NULL, data = NULL, stat = "identity", 
                        position = "identity", show.legend = NA, 
                        na.rm = FALSE, inherit.aes = TRUE, ...) {
  layer(data = data, 
        mapping = mapping,
        stat = stat,
        geom = GeomProportionBar,
        position = position,
        show.legend = show.legend,
        inherit.aes = inherit.aes,
        params = list(na.rm = na.rm, ...))
}
```

# create sankey diagrams
```{r}
# sankey bars
draw_panel_sankey_bar <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  failure_bar <- rectGrob(x = coords$x,
                          y = coords$yfailure + coords$gap/4,
                          width = coords$width,
                          height = 1 - coords$proportionsuccess - coords$gap/2,
                          gp = gpar(col = coords$col,
                                    fill = alpha(coords$fill_failure, coords$alpha),
                                    lwd = coords$size * .pt))
  
  success_bar <- rectGrob(x = coords$x,
                          y = coords$ysuccess - coords$gap/4,
                          width = coords$width,
                          height = coords$proportionsuccess - coords$gap/2,
                          gp = gpar(col = coords$col,
                                    fill = alpha(coords$fill_success, coords$alpha),
                                    lwd = coords$size * .pt))
  
  gTree(children = gList(failure_bar, success_bar))
  
}

GeomSankeyBar <- ggproto("GeomSankeyBar", Geom,
                      required_aes = c("x", "yfailure", "ysuccess", "proportionsuccess"),
                      default_aes = aes(col = NA,
                                        width = 0.2,
                                        fill_failure = "#818181",
                                        fill_success = "#db6159",
                                        alpha = 1,
                                        lwd = 2,
                                        size = 0.7,
                                        gap = 0.05),
                      draw_key = draw_key_rect,
                      draw_panel = draw_panel_sankey_bar)

geom_sankeybar <- function(mapping = NULL, data = NULL, stat = "identity", 
                        position = "identity", show.legend = NA, 
                        na.rm = FALSE, inherit.aes = TRUE, ...) {
  layer(data = data, 
        mapping = mapping,
        stat = stat,
        geom = GeomSankeyBar,
        position = position,
        show.legend = show.legend,
        inherit.aes = inherit.aes,
        params = list(na.rm = na.rm, ...))
}

# sankey flows
draw_panel_sankey_flow <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  flow <- polygonGrob(x = coords$x,
                      y = coords$y,
                      gp = gpar(col = coords$fillcol,
                                fill = coords$fillcol,
                                alpha = coords$alpha))

}

GeomSankeyFlow <- ggproto("GeomSankeyFlow", Geom,
                          required_aes = c("x", "y"),
                          default_aes = aes(fillcol = "gray50",
                                            alpha = 0.8),
                          draw_key = draw_key_polygon,
                          draw_panel = draw_panel_sankey_flow)

geom_sankeyflow <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomSankeyFlow,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}
```

# raw plot function
```{r}
plot_raw <- function(dabest_effectsize_obj, float_contrast) {
  enquo_x = dabest_effectsize_obj$enquo_x
  enquo_y = dabest_effectsize_obj$enquo_y
  enquo_id_col = dabest_effectsize_obj$enquo_id_col
  enquo_colour = dabest_effectsize_obj$enquo_colour
  proportional = dabest_effectsize_obj$proportional
  proportional_data = dabest_effectsize_obj$proportional_data
  
  raw_data <- dabest_effectsize_obj$raw_data
  Ns <- dabest_effectsize_obj$Ns
  raw_y_range_vector <- dabest_effectsize_obj$ylim
  
  raw_y_max <- raw_y_range_vector[2]
  raw_y_min <- raw_y_range_vector[1]
  raw_y_mean <- raw_y_max - raw_y_min
  
  test_summary <- dabest_effectsize_obj$test_summary
  control_summary <- dabest_effectsize_obj$control_summary
  is_paired <- dabest_effectsize_obj$is_paired
  
  idx <- dabest_effectsize_obj$idx
  raw_x_max = length(unlist(idx))
  x_axis_raw <- c(seq(1, raw_x_max,1))
  float.contrast <- float_contrast
  
  effsize_type <- dabest_effectsize_obj$delta_y_labels
  
  if (isTRUE(is_paired)) {
    raw_plot <- ggplot(raw_data, aes(x = x_axis_raw, y = !!enquo_y, colour = !!enquo_colour, 
                                     group = !!enquo_id_col)) +
      geom_line(aes(alpha = 0.8)) +
      scale_colour_manual(values=c("#4e6f85", "#b48459")) +
      guides(alpha="none", group="none")
  } else {
    if(isTRUE(proportional)){
      bar_width <- ifelse(float_contrast, 0.15, 0.10)
      # Plot unpaired proportion rawplot
      raw_plot <- ggplot(proportional_data) +
        geom_proportionbar(aes(x = x_axis_raw, 
                               ysuccess = y_success, 
                               yfailure = y_failure, 
                               proportionsuccess = proportion_success,
                               colour = !!enquo_x, 
                               fill = !!enquo_x,
                               width = bar_width)) +
        guides(colour = "none", fill = "none")
    } else {
      raw_plot <- ggplot(raw_data, aes(x = x_axis_raw, y = !!enquo_y, colour = !!enquo_x)) +
        geom_beeswarm(cex = 2) +
        scale_colour_manual(values=c("#4e6f85", "#b48459")) +
        guides(colour="none", alpha="none", group="none")
    }
    
    tufte_lines_df <- df_for_tufte(raw_data, enquo_x, enquo_y, proportional)
    
    # Aesthetics variables
    tufte_gap_value <- ifelse(proportional, min(tufte_lines_df$mean)/20, min(tufte_lines_df$mean)/50)
    tufte_side_adjust_value <- ifelse(proportional, 0, 0.1)
    
    row_num <- raw_x_max
    row_ref <- c(seq(1, row_num, 1)) + tufte_side_adjust_value
    x_ref <- row_ref
    
    y_top_t <-list(y = tufte_lines_df$mean + tufte_gap_value,  
                    yend = tufte_lines_df$upper_sd)
    y_bot_t <-list(y = tufte_lines_df$mean - tufte_gap_value, 
                    yend = tufte_lines_df$lower_sd) 
    if (isTRUE(str_detect(effsize_type, "edian"))) {
      y_top_t <-list(y = tufte_lines_df$median + tufte_gap_value,  
                    yend = tufte_lines_df$upper_quartile)
      y_bot_t <-list(y = tufte_lines_df$mean - tufte_gap_value, 
                    yend = tufte_lines_df$lower_quartile) 
    }
    # Adding tufte lines
    raw_plot <- raw_plot +
      geom_segment(data = tufte_lines_df, linewidth = 0.8,
               aes(x = row_ref, 
                   xend = row_ref, 
                   y = y_bot_t$y, 
                   yend = y_bot_t$yend),
               lineend = "square") +
      geom_segment(data = tufte_lines_df, linewidth = 0.8,
               aes(x = row_ref, 
                   xend = row_ref, 
                   y = y_top_t$y, 
                   yend = y_top_t$yend),
               lineend = "square")
  }
  if (isTRUE(float.contrast)){
    # left-right graph
    raw_plot <- raw_plot + 
      theme_classic() +
      float_contrast_theme +
      
      # Scale x-axis for alignment & add labels
      scale_x_continuous(limits = c(0.6,3),
                       expand = c(0,0),
                       breaks = c(1:raw_x_max),
                       labels = Ns$swarmticklabs) +
      
      # Redraw x-axis
      geom_segment(linewidth = 0.8, color = "black", x = 0, xend = 2.5, y = raw_y_min, yend = raw_y_min) +
      
      # Draw summary lines
      geom_segment(colour = "black",
                 linewidth = 0.3,
                 aes(x = 1, xend = 3, y = control_summary, yend = control_summary)) +
      geom_segment(colour = "black",
                 linewidth = 0.3,
                 aes(x = 2, xend = 3, y = test_summary, yend = test_summary))
  } else {
    # top-down graph
    raw_plot <- raw_plot + 
      theme_classic() +
      non_float_contrast_theme +
      
      # Scale x-axis for alignment & add labels
      scale_x_continuous(limits = c(0.8,3),
                       expand = c(0,0),
                       breaks = c(1:raw_x_max),
                       labels = Ns$swarmticklabs) +
      
      # Redraw x-axis line
      geom_segment(linewidth = 0.5, 
                   x = 1, 
                       xend = 2, 
                       y = raw_y_min + raw_y_mean/30, 
                       yend = raw_y_min + raw_y_mean/30,
                    color = "black",
                   lineend = "square") +
      
      # Redraw ticks
      geom_segment(linewidth = 0.5,
                   x = 1, 
                       xend = 1, 
                       y = raw_y_min + raw_y_mean/30, 
                       yend = raw_y_min,
                       color = "black",
                   lineend = "square") +
      geom_segment(linewidth = 0.5,
                   x = 2, 
                       xend = 2, 
                       y = raw_y_min + raw_y_mean/30, 
                       yend = raw_y_min,
                       color = "black",
                   lineend = "square")
  }
  raw_plot <- raw_plot +
    scale_y_continuous(limits = c(raw_y_min, raw_y_max), expand = c(0,0)) +
    labs(y = "value")

  return(raw_plot)
}
```

# custom violin & boot_ci geoms
```{r}
draw_panel_halfviolin <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  violin <- polygonGrob(x = coords$x,
                        y = coords$y,
                        gp = gpar(col = coords$col,
                                  fill = coords$fill,
                                  alpha = coords$alpha))

}

GeomHalfViolin <- ggproto("GeomHalfViolin", Geom,
                          required_aes = c("x", "y"),
                          default_aes = aes(col = "#ff800e", 
                                            fill = "#ff800e",
                                            alpha = 0.8),
                          draw_key = draw_key_point,
                          draw_panel = draw_panel_halfviolin)

geom_halfviolin <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomHalfViolin,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}

draw_panel_boot_ci <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
        
  ci_line <- segmentsGrob(x0 = coords$x,
                          x1 = coords$x,
                          y0 = coords$ymin,
                          y1 = coords$ymax,
                          gp = gpar(lwd = coords$size * .pt,
                                    lineend = coords$lineend))
  
  ci_dot <- pointsGrob(x = coords$x,
                       y = coords$middle,
                       pch = coords$shape)
  
  gTree(children = gList(ci_line, ci_dot))

}

GeomBootCI <- ggproto("GeomBootCI", Geom,
                      required_aes = c("x", "ymin", "ymax", "middle"),
                      default_aes = aes(size = 1.2,
                                        shape = 19, 
                                        lwd = 2,
                                        lineend = "square"),
                      draw_key = draw_key_point,
                      draw_panel = draw_panel_boot_ci)

geom_bootci <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomBootCI,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}
```

# delta_plot function 
```{r}
plot_delta <- function(dabest_effectsize_obj, float_contrast) {
  idx = dabest_effectsize_obj$idx
  bootstraps = dabest_effectsize_obj$bootstraps
  delta_x_labels = unlist(dabest_effectsize_obj$delta_x_labels)
  delta_y_labels = dabest_effectsize_obj$delta_y_labels
  delta_x_max = length(unlist(idx))
  float_contrast = float_contrast
  row_num = dabest_effectsize_obj$row_num
  raw_y_range_vector <- dabest_effectsize_obj$ylim
  control_summary <- dabest_effectsize_obj$control_summary
  test_summary <- dabest_effectsize_obj$test_summary
  
  # Extracting geom_bootci params
  ci_low = dabest_effectsize_obj$bca_ci_low
  ci_high = dabest_effectsize_obj$bca_ci_high
  difference = dabest_effectsize_obj$difference
  
  # Initialising ylim limits
  delta_y_max = .Machine$double.xmin
  delta_y_min = .Machine$double.xmax
  
  delta_plot <- ggplot()
  
  for(i in row_num){
    ci_coords <- density(bootstraps[[1]])
    x_coords_ci <- ci_coords$x
    y_coords_ci <- ci_coords$y
    
    # Standardise y
    y_coords_ci <- (y_coords_ci - min(y_coords_ci))/(max(y_coords_ci) - min(y_coords_ci))
    y_coords_ci <- y_coords_ci/4
    
    if(isTRUE(float_contrast)){
      y_coords_ci <- y_coords_ci*2 + i
    }else{
      y_coords_ci <- y_coords_ci + i
    }
    
    min_x_coords <- min(x_coords_ci)
    max_x_coords <- max(x_coords_ci)
    
    # Keeping track of ylim limits
    if(min_x_coords < delta_y_min){
      delta_y_min <- min_x_coords
    }
    if(max_x_coords > delta_y_max){
      delta_y_max <- max_x_coords
    }
    
    delta_plot <- delta_plot +
      geom_halfviolin(aes(x = y_coords_ci, y = x_coords_ci))
    
  }
  delta_plot <- delta_plot +
    geom_bootci(aes(x = row_num,
                    ymin = ci_low,
                    ymax = ci_high,
                    middle = difference))
  
  delta_y_mean <- (delta_y_max - delta_y_min)/2
  
  if(isTRUE(float_contrast)){
    # left-right graph
    # Calculate new ylims to align summary lines
    min_raw_y <- raw_y_range_vector[1]
    raw_y_range <- raw_y_range_vector[2] - raw_y_range_vector[1]
    min_y_coords <- difference/(1 - (test_summary - min_raw_y)/(control_summary - min_raw_y))
    delta_y_range <- raw_y_range * -min_y_coords/(control_summary - min_raw_y)
    
    delta_plot <- delta_plot +
      theme_classic() +
      
      # Draw summary lines
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 1.5, 
                       xend = 3, 
                       y = difference, 
                       yend = difference)) +
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 1.5, 
                       xend = 3, 
                       y = 0, 
                       yend = 0)) +
      
      # Extend x-axis & add labels
      scale_x_continuous(limits = c(1.5,3),
                         expand = c(0,0),
                         breaks = c(2),
                         labels = delta_x_labels[2]) +
      
      # Scale y-axis for alignment of summary lines & change position of y-axis to right
      scale_y_continuous(limits = c(min_y_coords, 
                                    min_y_coords + delta_y_range),
                         expand = c(0, 0),
                         position = "right") +
      float_contrast_theme +
      
      # Redraw x-axis line
      geom_hline(linewidth = 0.8,
                 yintercept = min_y_coords)
    
  } else {
    # top-down graph
    # Scale x-axis for alignment & add labels
    delta_plot <- delta_plot +
      theme_classic() +
      scale_x_continuous(limits = c(0.8,3),
                         expand = c(0,0),
                         breaks = c(1:delta_x_max),
                         labels = delta_x_labels) +
      non_float_contrast_theme +
      
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 0.8, 
                       xend = 3, 
                       y = 0, 
                       yend = 0)) +
      scale_y_continuous(limits = c(delta_y_min - delta_y_mean/10, 
                                    delta_y_max + delta_y_mean/10),
                         expand = c(0,0))
    
    # settle aesthetics of the x-axis, try to make it look like the python ver
    # should be a for loop but its not going to be for now
    # for loop is for j in length(idx)
    #               for k in length(idx[[i]])
  
    delta_plot <- delta_plot +
      
      # Redraw x-axis line
      geom_segment(linewidth = 0.5, 
                   aes(x = 1, 
                       xend = 2, 
                       y = delta_y_min - delta_y_mean/15, 
                       yend = delta_y_min - delta_y_mean/15),
                   lineend = "square") +
      
      # Redraw ticks
      geom_segment(linewidth = 0.5,
                   aes(x = 1, 
                       xend = 1, 
                       y = delta_y_min - delta_y_mean/15, 
                       yend = delta_y_min - delta_y_mean/10),
                   lineend = "square") +
      geom_segment(linewidth = 0.5,
                   aes(x = 2, 
                       xend = 2, 
                       y = delta_y_min - delta_y_mean/15, 
                       yend = delta_y_min - delta_y_mean/10),
                   lineend = "square")
  }
  
  delta_plot <- delta_plot +
    labs(y = delta_y_labels)
  
  return(delta_plot)
}
```

# dabest_plot functin
```{r}
dabest_plot <- function(dabest_obj.mean_diff, float_contrast = TRUE) {
  if (isFALSE(float_contrast)) {
    cowplot::plot_grid(
    plotlist   = list(plot_raw(dabest_obj.mean_diff, float_contrast=FALSE), 
                      plot_delta(dabest_obj.mean_diff, float_contrast=FALSE)),
    nrow       = 2,
    ncol       = 1,
    axis       = "lr",
    align      = "b")
  } else {
    cowplot::plot_grid(
    plotlist   = list(plot_raw(dabest_obj.mean_diff, float_contrast=TRUE), 
                      plot_delta(dabest_obj.mean_diff, float_contrast=TRUE)),
    nrow       = 1,
    ncol       = 2,
    rel_widths = c(0.7, 0.2),
    axis       = "lr",
    align      = "h")
  }
}
```

# Testing dataset
```{r}
set.seed(12345)

N = 40
c1 <- rnorm(N, mean = 100, sd = 25)
c2 <- rnorm(N, mean = 100, sd = 50)
g1 <- rnorm(N, mean = 120, sd = 25)
g2 <- rnorm(N, mean = 80, sd = 50)
g3 <- rnorm(N, mean = 100, sd = 12)
g4 <- rnorm(N, mean = 100, sd = 50)
gender <- c(rep('Male', N/2), rep('Female', N/2))
dummy <- rep("Dummy", N)
id <- 1: N

wide.data <- tibble::tibble(
  Control1 = c1, Control2 = c2,
  Group1 = g1, Group2 = g2, Group3 = g3, Group4 = g4,
  Dummy = dummy,
  Gender = gender, ID = id)

my.data <- wide.data %>%
  tidyr::gather(key = Group, value = Measurement, -ID, -Gender, -Dummy)
```


# Testing unpaired plots
```{r}
dabest_obj <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1"))
dabest_obj.mean_diff <- mean_diff(dabest_obj)
dabest_obj.hedges_g <- hedges_g(dabest_obj)
dabest_obj.median_diff <- median_diff(dabest_obj)

# alternative way of plotting is
# dabest_obj.mean_diff.plot <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1")) %>%
#   mean_diff() %>%
#   dabest_plot()
# 
# dabest_obj.mean_diff.plot
```

```{r}
dabest_plot(dabest_obj.hedges_g, TRUE)
dabest_plot(dabest_obj.hedges_g, FALSE)
```
# Testing paired plots 
```{r}
dabest_obj <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1"), is_paired = TRUE, id_col = ID)
dabest_obj.paired_mean_diff <- mean_diff(dabest_obj)
dabest_obj.paired_median_diff <- median_diff(dabest_obj)
```

```{r}
dabest_plot(dabest_obj.paired_median_diff, TRUE)
dabest_plot(dabest_obj.paired_median_diff, FALSE)
```

# Testing proportional dataset
```{r}
set.seed(12345)

N = 40

my.data.control_proportional <- data.frame(
  Group = sample(c("Control1"), 40, TRUE)
)
my.data.control_proportional$Success <- numeric(nrow(my.data.control_proportional))
my.data.control_proportional$Success[sample(nrow(my.data.control_proportional), 8)] <- 1

my.data.test_proportion <- data.frame(
  Group = sample(c("Test1"), 40, TRUE)
)
my.data.test_proportion$Success <- numeric(nrow(my.data.test_proportion))
my.data.test_proportion$Success[sample(nrow(my.data.test_proportion), 22)] <- 1

my.data.proportional <- rbind(my.data.control_proportional, my.data.test_proportion)
id <- data.frame(ID = rep(c(1:40), 2))
my.data.proportional <- cbind(my.data.proportional, id)
```

```{r}
dabest_obj_proportional.mean_diff <- load(data = my.data.proportional, 
                                  x = Group, 
                                  y = Success, 
                                  idx = c("Control1", "Test1"),
                                  proportional = TRUE) %>%
  mean_diff()
```

```{r}
dabest_plot(dabest_obj_proportional.mean_diff, TRUE)
dabest_plot(dabest_obj_proportional.mean_diff, FALSE)
```

```{r}
dabest_obj_proportional.cohens_h <- load(data = my.data.proportional, 
                                  x = Group, 
                                  y = Success, 
                                  idx = c("Control1", "Test1"),
                                  proportional = TRUE) %>%
  cohens_h()
```

```{r}

dabest_plot(dabest_obj_proportional.cohens_h, TRUE)
dabest_plot(dabest_obj_proportional.cohens_h, FALSE)
```