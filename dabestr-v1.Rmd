---
title: "dabestr-v1"
output: 
  html_document:
    toc: true
    toc_float: true
    df_print: paged
date: '2023-06-24'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(stringr)
library(lubridate)
library(cowplot)
library(rlang)
library(magrittr)
library(ggbeeswarm)
library(boot)
library(effsize)
library(grid)
library(scales)
```

# load function
```{r}
load <- function(
    data,
    x = NULL,
    y = NULL,
    idx = NULL,
    is_paired = FALSE,
    id_col = NULL,
    ci = 95,
    colour = NULL,
    proportional = FALSE
    ){
  
  # Storing plotting params as quosures
  enquo_x <- enquo(x)
  enquo_y <- enquo(y)
  enquo_id_col <- enquo(id_col)
  enquo_colour <- enquo(colour)
  
  name_x <- as_name(enquo_x)
  name_y <- as_name(enquo_y)
  
  if (!is.null(idx)){
    raw_data <- data %>%
      filter(!!enquo_x %in% idx) %>%
      
      # (to be changed later for multi-group)
      mutate(x_axis_raw = case_when(
        Group == idx[1] ~ 1,
        Group == idx[2] ~ 2,
      )) 
    
    # Obtain raw_y_range_vector
    ylim <- range(raw_data[[name_y]])
    
    # Creation of x-axis label
    Ns <- raw_data %>%
      dplyr::group_by(!!enquo_x) %>%
      dplyr::count()
    Ns$swarmticklabs <- do.call(paste, c(Ns[c(name_x, "n")], sep = "\nN = "))
    
    # (to be changed later for multi-group)
    buffer_Ns <- data.frame(Group = "", n = 0, swarmticklabs = "") 
    Ns <- rbind(Ns)
    
    if(isTRUE(proportional)){
      ## include checks here for data to see if it is proportional data
      proportional_data <- raw_data %>%
        select(!!enquo_x, !!enquo_y, !!enquo_id_col, !!enquo_colour) %>%
        group_by(!!enquo_x) %>%
        summarise(proportion_success = mean(!!enquo_y),
                  y_success = proportion_success/2,
                  y_failure = (1+proportion_success)/2)
      
      control_summary <- proportional_data$proportion_success[1]
      test_summary <- proportional_data$proportion_success[2]
        
    } else {
      
      # Extending ylim for plotting
      ylim[1] <- ylim[1] - (ylim[2]-ylim[1])/10
      ylim[2] <- ylim[2] + (ylim[2]-ylim[1])/10
      
      # Calculation of summary lines
      summaries <- raw_data %>%
        group_by(!!enquo_x) %>%
        summarise(summary_stats = mean(!!enquo_y))
      
      control_summary <- summaries$summary_stats[1]
      test_summary <- summaries$summary_stats[2]
      
      proportional_data <- NULL
    }
    
    dabest_object <- list(
      raw_data = raw_data,
      proportional_data = proportional_data,
      enquo_x = enquo_x,
      enquo_y = enquo_y,
      enquo_id_col = enquo_id_col,
      enquo_colour = enquo_colour,
      proportional = proportional,
      idx = idx,
      is_paired = is_paired,
      ci = ci,
      Ns = Ns,
      control_summary = control_summary,
      test_summary = test_summary,
      ylim = ylim
    )
    
    class(dabest_object) <- c("dabest")
    
    return(dabest_object)
  }
  stop()
}
```

# Bootstrap helper functions
```{r}
effsize_boot <- function(
    data, 
    effect_size_func, 
    reps = 5000, 
    paired = FALSE
    ){
  
  s <- c(rep(1, length(data$control)),
         rep(2, length(data$test)))

  bootboot <- function(d, indices, paired) {
    c <- d[indices[s == 1]]
    t <- d[indices[s == 2]]

    return(effect_size_func(c, t, paired))
  }

  b <- boot(
    c(data$control, data$test),
    statistic = bootboot,
    R = reps,
    strata = s,
    paired = paired)

  return(b)
}

bootstrap <- function(
    dabest_obj,
    effect_size_func,
    seed = 12345,
    reps = 5000,
    boot_labs
    ){
  
  result <- tibble()
  
  raw_data <- dabest_obj$raw_data
  idx <- dabest_obj$idx
  idx <- list(idx)
  enquo_x <- dabest_obj$enquo_x
  enquo_y <- dabest_obj$enquo_y
  ci <- dabest_obj$ci
  is_paired <- dabest_obj$is_paired
  
  quoname_x <- as_name(enquo_x)
  quoname_y <- as_name(enquo_y)
  delta_x_labels <- list()
  delta_y_labels <- boot_labs
  
  for(group in idx){
    ctrl_tibble <- raw_data %>% 
      filter(!!enquo_x == !!group[1])
    ctrl_measurement <- ctrl_tibble[[quoname_y]]
    
    test_tibble <- raw_data %>%
      filter(!!enquo_x == !!group[2])
    test_measurement <- test_tibble[[quoname_y]]
    
    xlabels <- paste(group[2],group[1],sep="\nminus\n")
    to_add_xlabels <- c("", xlabels)
    delta_x_labels <- append(delta_x_labels,to_add_xlabels)
    
    control_test_measurement <- list(control = ctrl_measurement,
                                     test = test_measurement)
    set.seed(seed)
    
    boot_result <- effsize_boot(
      data = control_test_measurement,
      effect_size_func = effect_size_func,
      reps=reps,
      paired=is_paired
    )
    
    if (ci < 0 | ci > 100) {
      err_string <- str_interp(
        "`ci` must be between 0 and 100, not ${ci}"
      )
      stop(err_string)
    }
    
    bootci <- boot.ci(boot_result,conf=ci/100,type = c("perc","bca"))
    
    row <- list(
      bootstraps = list(as.vector(boot_result$t)),
      idx = idx,
      delta_x_labels = delta_x_labels,
      delta_y_labels = delta_y_labels,
      row_num = 2,
      bca_ci_low = bootci$bca[4],
      bca_ci_high = bootci$bca[5],
      difference = boot_result$t0,
      raw_data = raw_data,
      is_paired = is_paired,
      Ns = dabest_obj$Ns,
      control_summary = dabest_obj$control_summary,
      test_summary = dabest_obj$test_summary,
      ylim = dabest_obj$ylim,
      enquo_x = dabest_obj$enquo_x,
      enquo_y = dabest_obj$enquo_y,
      enquo_id_col = dabest_obj$enquo_id_col,
      enquo_colour = dabest_obj$enquo_colour,
      proportional = dabest_obj$proportional,
      proportional_data = dabest_obj$proportional_data
    )
  }
  return(row)
}
```

# Main effect_size functions
```{r}
mean_diff <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    if (identical(paired, FALSE)) {
      return(mean(test) - mean(control))
    }
    return(mean(test - control))
  }
  
  is_paired <- dabest_obj$is_paired
  
  if(is_paired){
    return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Paired mean difference"))
  }
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Mean difference"))
}

median_diff <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    if (identical(paired, FALSE)) {
      return(median(test) - median(control))
    }
    return(median(test - control))
  }
  
  is_paired <- dabest_obj$is_paired
  
  if(is_paired){
    return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Paired median difference"))
  }
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Median difference"))
}

cohens_d <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired) {
    return(effsize::cohen.d(test, control, paired=paired)$estimate)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cohen's d"))
}

hedges_g <- function(dabest_obj) {
  
  cohens_d_ <- function(control, test, paired) {
    return(effsize::cohen.d(test, control, paired=paired)$estimate)
  }
  
  effect_size_func <- function(control, test, paired) {
    cd <- cohens_d_(test, control, paired=paired)
    corr.factor <- -hedges_correction(test, control)
    return(cd * corr.factor)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Hedges' g"))
}

cliffs_delta <- function(dabest_obj) {
  
  effect_size_func <- function(control, test, paired=NA) {
    return(effsize::cliff.delta(test, control)$estimate)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cliffs' delta"))
}

cohens_h <- function(dabest_obj){
  
  effect_size_func <- function(control, test, paired) {
    #remove nas and nulls later on
    prop_control <- mean(control)
    prop_test <- mean(test)

    # Arcsine transformation
    phi_control <- 2 * asin(sqrt(prop_control))
    phi_test <- 2 * asin(sqrt(prop_test))
    result <- phi_test - phi_control
    return(result)
  }
  
  return(bootstrap(dabest_obj, effect_size_func, boot_labs = "Cohen's h"))
}

hedges_correction <- function(x1, x2) {

  n1 <- length(x1)
  n2 <- length(x2)

  deg.freedom <- n1 + n2 - 2
  numer       <- gamma(deg.freedom/2)
  denom0      <- gamma((deg.freedom - 1) / 2)
  denom       <- sqrt((deg.freedom / 2)) * denom0

  if (is.infinite(numer) | is.infinite(denom)) {
    # Occurs when df is too large.
    # Applies Hedges and Olkin's approximation.
    df.sum <- n1 + n2
    denom <- (4 * df.sum) - 9
    out <- 1 - (3 / denom)
  } else out <- numer / denom

  return(out)
}
```

# float_contrast/non_float_contrast themes
```{r}
# Theme for left-right graph
float_contrast_theme <- 
  theme(plot.margin = ggplot2::unit(c(5.5, 0, 5.5, 0), "pt"),
        axis.line.x = ggplot2::element_blank(), 
        axis.title.x = ggplot2::element_blank(), 
        axis.ticks.x = ggplot2::element_blank(),
        axis.title.x.bottom = ggplot2::element_blank(),
        legend.position = "left",
        legend.justification = "top",
        legend.title=element_blank())

# Theme for top-down graph
non_float_contrast_theme <- 
  theme(axis.line.x = ggplot2::element_blank(), 
        axis.title.x = ggplot2::element_blank(), 
        axis.ticks.x = ggplot2::element_blank(),
        axis.title.x.bottom = ggplot2::element_blank(),
        axis.title.y = element_text(size = 10),
        legend.position = "left",
        legend.justification = "top",
        legend.title=element_blank())

```

# helper math stats tool functions
```{r}
sigmoid <- function(x_from, factor, y_from, y_to, smooth = 5.5, n = 300) {
  x <- seq(-smooth, smooth, length = n)
  y <- exp(x) / (exp(x) + 1)
  out <- data.frame(x = (x + smooth) / (smooth * 2) * factor + x_from,
                    y = y * (y_to - y_from) + y_from)
}

flipped_sig <- function(x_from, factor, y_from, y_to, smooth = 5.5, n = 300) {
  x <- seq(-smooth, smooth, length = n)
  y <- -exp(-x) / (exp(-x) + 1)
  out <- data.frame(x = (x + smooth) / (smooth * 2) * factor + x_from,
                    y = y * (y_to - y_from) + y_to)
}
```

# df creation functions
```{r}
# Function for creation of df for tuftelines plot
df_for_tufte <- function(raw_data, enquo_x, enquo_y, proportional){
  tufte_lines_df <- raw_data %>%
    dplyr::group_by(!!enquo_x) %>%
    dplyr::summarize(mean = mean(!!enquo_y),
                     median = median(!!enquo_y),
                     sd = sd(!!enquo_y),
                     lower_quartile = stats::quantile(!!enquo_y)[2],
                     upper_quartile = stats::quantile(!!enquo_y)[4])
  
  if(isTRUE(proportional)){
    tufte_lines_df <- tufte_lines_df %>%
      dplyr::mutate(sd = sd/10)
  }
  tufte_lines_df <- tufte_lines_df %>%
    dplyr::mutate(lower_sd = mean - sd, upper_sd = mean + sd)
  
  return(tufte_lines_df)
}

create_dfs_for_sankey <- function(float_contrast = FALSE, 
                                 raw_data, 
                                 proportional_data, 
                                 enquo_id_col, 
                                 x_axis_raw, 
                                 ind = 1,
                                 scale_factor_sig = 0.8,
                                 gap
                                 ) {
  ind <- 1
  bar_width <- ifelse(float_contrast, 0.15, 0.10)
  means_c_t <- proportional_data$proportion_success
  #for() will use for loops for multiple plot groups
  success_success <- raw_data %>%
    group_by(!!enquo_id_col) %>%
    summarise(success_change = 
                any(Success == 1 & Group == "Control1") & 
                any(Success == 1 & Group == "Test1")) %>%
    filter(success_change) %>%
    summarise(C1T1 = n()/N)
  failure_failire <- raw_data %>%
    group_by(!!enquo_id_col) %>%
    summarise(success_change = 
                any(Success == 0 & Group == "Control1") & 
                any(Success == 0 & Group == "Test1")) %>%
    filter(success_change) %>%
    summarise(C1T1F = n()/N)
  
  # find values for lower flow success to failure flow
  ss <- success_success$C1T1[1]
  value_start1 <- success_success$C1T1[1] - gap/8
  value_start2 <- means_c_t[1]- gap/2 - gap/8
  value_end1 <- means_c_t[2] + gap/2 +gap/8
  value_end2 <- 1- failure_failire$C1T1F[1] + gap/8
  
  
  # find values for upper flppied flow success to failure flow
  flow_start1 <- 1- failure_failire$C1T1F[1]
  flow_end1 <- means_c_t[2] - gap/2
  flow_start2 <- means_c_t[1] + gap/2
  flow_end2 <- success_success$C1T1[1]
  
  # form dataframes from sigmoid/ flippedSig functions and the rectangles, later fit into sankeyflow
  sig1 <- sigmoid(ind + bar_width, scale_factor_sig, value_start1, value_end1)
  sig2 <- sigmoid(ind + bar_width, scale_factor_sig, value_start2, value_end2)
  sig1 <- arrange(sig1, desc(x))
  sig3 <- flipped_sig(ind + bar_width, scale_factor_sig, flow_start1, flow_end1)
  sig4 <- flipped_sig(ind + bar_width, scale_factor_sig, flow_start2, flow_end2)
  sig4 <- arrange(sig4, desc(x))
  data_for_flow1 <- rbind(sig2, sig1)
  data_for_flow2 <- rbind(sig3, sig4)
  data_for_rect_top <- data.frame(
    x = c(x_axis_raw, rev(x_axis_raw)), 
    y = c(1, 1, rep(flow_start1, 2)))
  data_for_rect_bot <- data.frame(
    x = c(x_axis_raw, rev(x_axis_raw)), 
    y = c(rep(ss,2), 0, 0))
  
  #prepare data for bargraphs of paired proportional data
  data_for_bars <- proportional_data
  
  
  list_of_dfs <- list(
    flow1 = data_for_flow1,
    flow2 = data_for_flow2, 
    rect_top = data_for_rect_top, 
    rect_bot = data_for_rect_bot,
    bars = proportional_data
  )
  list_of_dfs
}

create_dfs_for_xaxis_redraw <- function(idx) {
  x_axis_pointer <- 0
  xaxis_line_x_vector <- c()
  xaxis_line_xend_vector <- c()
  xaxis_ticks_x_vector <- c()
  
    for (j in 1:length(idx)) {
      # calculate xaxis line x coords
      x_coord <- x_axis_pointer + 1
      xaxis_line_x_vector <- append(xaxis_line_x_vector, x_coord)
      xend_coord <- x_axis_pointer + length(idx[[j]])
      xaxis_line_xend_vector <- append(xaxis_line_xend_vector, xend_coord)

      # calculate xaxis ticks x coords
      for (k in 1:length(idx[[j]])) {
        x_coord <- x_axis_pointer + k
        xaxis_ticks_x_vector <- append(xaxis_ticks_x_vector, x_coord)

      }
      x_axis_pointer <- length(idx[[j]])
    }
  
  dfs_for_xaxis_redraw <- list(
    df_for_line = data.frame(x = xaxis_line_x_vector,
                              xend = xaxis_line_xend_vector),
    df_for_ticks = data.frame(x = xaxis_ticks_x_vector)
  )
  
  return(dfs_for_xaxis_redraw)
}

create_plot_components <- function(proportional, 
                                   is_paired, 
                                   float_contrast) {
  main_plot_type <- ""
  is_summary_lines <- TRUE
  is_tufte_lines <- TRUE
  
  if (isTRUE(proportional)) {
    if (isFALSE(is_paired)) {
      
      main_plot_type <- "unpaired proportions"
      
      if(isTRUE(float_contrast)){
        
          is_summary_lines <- TRUE
          
      } else {
        
          is_summary_lines <- FALSE
      }
      
    } else {
      
      main_plot_type <- "sankey"
      is_summary_lines <- FALSE
      
    }
  } else {
    if (isFALSE(is_paired)) {
      
      main_plot_type <- "swarmplot"
      
      if(isTRUE(float_contrast)){
        
          is_summary_lines <- TRUE
          
      } else {
        
          is_summary_lines <- FALSE
          
      }
    } else {
      
      main_plot_type <- "slope"
      is_tufte_lines <- FALSE
      
      if(isTRUE(float_contrast)){
        
        is_summary_lines <- TRUE
        
      } else {
        
        is_summary_lines <- FALSE
      }
    }
  }
  
  plot_component <- list(
    main_plot_type = main_plot_type,
    is_summary_lines = is_summary_lines,
    is_tufte_lines = is_tufte_lines
  )
  return(plot_component)
}
```

# custom proportionbar geom
```{r}
"%||%" <- function(a, b) {
  if (!is.null(a)) a else b
}

draw_panel_proportion_bar <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  failure_bar <- rectGrob(x = coords$x,
                          y = 1,
                          width = coords$width,
                          height = 1 - coords$y,
                          default.units = "native",
                          just = c("center", "top"),
                          gp = gpar(col = coords$colour,
                                    fill = "white",
                                    lwd = coords$size * .pt))
  
  success_bar <- rectGrob(x = coords$x,
                          y = 0,
                          width = coords$width,
                          height = coords$y,
                          default.units = "native",
                          just = c("center", "bottom"),
                          gp = gpar(col = coords$colour,
                                    fill = alpha(coords$fill, coords$alpha),
                                    lwd = coords$size * .pt))
  
  gTree(children = gList(failure_bar, success_bar))
  
}

GeomProportionBar <- ggproto("GeomProportionBar", GeomRect,
                      required_aes = c("x", "y"),
                      non_missing_aes = c("xmin", "xmax", "ymin", "ymax"),
                      default_aes = aes(colour = NA,
                                        width = 0.2,
                                        fill = "grey35",
                                        alpha = NA,
                                        lwd = 2,
                                        size = 0.7),
                      
                      set_up_data = function(data, params) {
                        data$width <- data$width %||% params$width
                        data <- transform(data,
                          ymin = pmin(y, 0), ymax = pmax(y, 1),
                          xmin = x - width, xmax = x + width,
                          width = width)
                        data
                      },
                      
                      draw_key = draw_key_polygon,
                      draw_panel = draw_panel_proportion_bar)

geom_proportionbar <- function(mapping = NULL, data = NULL, 
                               stat = "identity", position = "stack", 
                               ...,
                               show.legend = NA, 
                               na.rm = FALSE, 
                               inherit.aes = TRUE) {
  layer(data = data, 
        mapping = mapping,
        stat = stat,
        geom = GeomProportionBar,
        position = position,
        show.legend = show.legend,
        inherit.aes = inherit.aes,
        params = list(
          na.rm = na.rm, 
          ...))
}
```

# create sankey diagrams
```{r}
# sankey bars
draw_panel_sankey_bar <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  failure_bar <- rectGrob(x = coords$x,
                          y = coords$yfailure + coords$gap/4,
                          width = coords$width,
                          height = 1 - coords$proportionsuccess - coords$gap/2,
                          gp = gpar(col = coords$col,
                                    fill = alpha(coords$fill_failure, coords$alpha),
                                    lwd = coords$size * .pt))
  
  success_bar <- rectGrob(x = coords$x,
                          y = coords$ysuccess - coords$gap/4,
                          width = coords$width,
                          height = coords$proportionsuccess - coords$gap/2,
                          gp = gpar(col = coords$col,
                                    fill = alpha(coords$fill_success, coords$alpha),
                                    lwd = coords$size * .pt))
  
  gTree(children = gList(failure_bar, success_bar))
  
}

GeomSankeyBar <- ggproto("GeomSankeyBar", Geom,
                      required_aes = c("x", "yfailure", "ysuccess", "proportionsuccess"),
                      default_aes = aes(col = NA,
                                        width = 0.2,
                                        fill_failure = "#818181",
                                        fill_success = "#db6159",
                                        alpha = 1,
                                        lwd = 2,
                                        size = 0.7,
                                        gap = 0.05),
                      draw_key = draw_key_rect,
                      draw_panel = draw_panel_sankey_bar)

geom_sankeybar <- function(mapping = NULL, data = NULL, stat = "identity", 
                        position = "identity", show.legend = NA, 
                        na.rm = FALSE, inherit.aes = TRUE, ...) {
  layer(data = data, 
        mapping = mapping,
        stat = stat,
        geom = GeomSankeyBar,
        position = position,
        show.legend = show.legend,
        inherit.aes = inherit.aes,
        params = list(na.rm = na.rm, ...))
}

# sankey flows
draw_panel_sankey_flow <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  flow <- polygonGrob(x = coords$x,
                      y = coords$y,
                      gp = gpar(col = coords$fillcol,
                                fill = coords$fillcol,
                                alpha = coords$alpha))

}

GeomSankeyFlow <- ggproto("GeomSankeyFlow", Geom,
                          required_aes = c("x", "y"),
                          default_aes = aes(fillcol = "gray50",
                                            alpha = 0.8),
                          draw_key = draw_key_polygon,
                          draw_panel = draw_panel_sankey_flow)

geom_sankeyflow <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomSankeyFlow,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}
```

# raw plot function
```{r}
plot_raw <- function(dabest_effectsize_obj, float_contrast) {
  enquo_x = dabest_effectsize_obj$enquo_x
  enquo_y = dabest_effectsize_obj$enquo_y
  enquo_id_col = dabest_effectsize_obj$enquo_id_col
  enquo_colour = dabest_effectsize_obj$enquo_colour
  proportional = dabest_effectsize_obj$proportional
  proportional_data = dabest_effectsize_obj$proportional_data
  
  raw_data <- dabest_effectsize_obj$raw_data
  Ns <- dabest_effectsize_obj$Ns
  raw_y_range_vector <- dabest_effectsize_obj$ylim
  
  raw_y_max <- raw_y_range_vector[2]
  raw_y_min <- raw_y_range_vector[1]
  raw_y_mean <- raw_y_max - raw_y_min
  
  test_summary <- dabest_effectsize_obj$test_summary
  control_summary <- dabest_effectsize_obj$control_summary
  is_paired <- dabest_effectsize_obj$is_paired
  
  idx <- dabest_effectsize_obj$idx
  raw_x_max = length(unlist(idx))
  x_axis_raw <- c(seq(1, raw_x_max,1))
  
  effsize_type <- dabest_effectsize_obj$delta_y_labels
  
  # check if multiplot
  if(length(idx) >= 2) {
    float_contrast = FALSE
  }
  
  plot_components <- create_plot_components(proportional, is_paired, float_contrast)
  main_plot_type <- plot_components$main_plot_type
  is_summary_lines <- plot_components$is_summary_lines
  is_tufte_lines <- plot_components$is_tufte_lines
  
  if(main_plot_type == "sankey"){
    sankey_bar_gap <- 0.02
    sankey_df <- create_dfs_for_sankey(float_contrast = float_contrast, 
                                       raw_data = raw_data,
                                       proportional_data = proportional_data,
                                       enquo_id_col = enquo_id_col,
                                       x_axis_raw = x_axis_raw,
                                       gap = sankey_bar_gap)
    flow1 <- sankey_df$flow1
    flow2 <- sankey_df$flow2
    rect_top <- sankey_df$rect_top
    rect_bot <- sankey_df$rect_bot
    bars <- sankey_df$bars
  }
  
  bar_width <- ifelse(float_contrast, 0.15, 0.10)
  
  # Initialise raw_plot and add main_plot_type component
  raw_plot <- switch(
    main_plot_type,
    
    "swarmplot" =
      ggplot() +
      # to add: need to handle colour for swarm & slope graphs
      geom_beeswarm(data = raw_data, 
                    aes(x = x_axis_raw, 
                        y = !!enquo_y, 
                        colour = !!enquo_x),
                    cex = 2) +
      guides(colour = "none", alpha = "none", group = "none"),
    
    "slope" = 
      ggplot() +
      geom_line(data = raw_data,
                aes(x = x_axis_raw, 
                    y = !!enquo_y,
                    colour = !!enquo_colour,
                    group = !!enquo_id_col,
                    alpha = 0.8)) +
      guides(alpha = "none", group = "none"),
    
    "unpaired proportions" = 
      ggplot() +
      geom_proportionbar(data = proportional_data,
                         aes(x = x_axis_raw,
                             y = proportion_success,
                             colour = !!enquo_x, 
                             fill = !!enquo_x,
                             width = bar_width)) +
      guides(colour = "none", fill ="none"),
    
    "sankey" =
      ggplot() +
      geom_sankeyflow(data = flow1, 
                      aes(x = x, y = y, fillcol = "#db6159")) +
      geom_sankeyflow(data = flow2, 
                      aes(x = x, y = y, fillcol = "#818181")) +
      geom_sankeyflow(data = rect_top, 
                      aes(x = x, y = y, fillcol = "#818181")) +
      geom_sankeyflow(data = rect_bot, 
                      aes(x = x, y = y, fillcol = "#db6159")) +
      geom_sankeybar(data = bars, 
                     aes(x = x_axis_raw,
                         ysuccess = y_success, 
                         yfailure = y_failure, 
                         proportionsuccess = proportion_success, 
                         width = bar_width,
                         gap = sankey_bar_gap))
  )
  
  # Add scaling to axis & theme
  raw_plot <- raw_plot +
    theme_classic() +
    coord_cartesian(ylim = c(raw_y_min, raw_y_max),
                    xlim = c(0.6,raw_x_max+1),
                    expand = FALSE) +
    scale_x_continuous(breaks = c(1:raw_x_max),
                       labels = Ns$swarmticklabs)
  
  # Add summary_lines component
  if(isTRUE(is_summary_lines)) {
    raw_plot <- raw_plot +
      geom_segment(colour = "black",linewidth = 0.3,
                   aes(x = 1, 
                       xend = raw_x_max+1,
                       y = control_summary, 
                       yend = control_summary)) +
      geom_segment(colour = "black", linewidth = 0.3,
                   aes(x = 2, 
                       xend = raw_x_max+1, 
                       y = test_summary, 
                       yend = test_summary))
  }
  
  # Add tufte_lines component
  if(isTRUE(is_tufte_lines)) {
    tufte_lines_df <- df_for_tufte(raw_data, enquo_x, enquo_y, proportional)
    if(main_plot_type == "sankey"){
      tufte_gap_value <- sankey_bar_gap
    } else {
      tufte_gap_value <- ifelse(proportional, min(tufte_lines_df$mean)/20, min(tufte_lines_df$mean)/50)
      tufte_gap_value <- ifelse(float_contrast, tufte_gap_value, tufte_gap_value*2)
    }
    tufte_side_adjust_value <- ifelse(proportional, 0, 0.15)
    
    row_num <- raw_x_max
    row_ref <- c(seq(1, row_num, 1)) + tufte_side_adjust_value
    x_ref <- row_ref
    
    y_top_t <-list(y = tufte_lines_df$mean + tufte_gap_value,  
                   yend = tufte_lines_df$upper_sd)
    y_bot_t <-list(y = tufte_lines_df$mean - tufte_gap_value, 
                   yend = tufte_lines_df$lower_sd) 
    if (isTRUE(str_detect(effsize_type, "edian"))) {
      y_top_t <-list(y = tufte_lines_df$median + tufte_gap_value,  
                     yend = tufte_lines_df$upper_quartile)
      y_bot_t <-list(y = tufte_lines_df$mean - tufte_gap_value, 
                     yend = tufte_lines_df$lower_quartile) 
    }
    
    # to change: temporary fix for tufte lines black for proportional graphs
    if(isTRUE(proportional)) {
      raw_plot <- raw_plot +
        geom_segment(data = tufte_lines_df, 
                     linewidth = 0.8,
                     colour = "black",
                     aes(x = row_ref, 
                         xend = row_ref, 
                         y = y_bot_t$y, 
                         yend = y_bot_t$yend,
                         colour = !!enquo_x),
                     lineend = "square") +
        geom_segment(data = tufte_lines_df, 
                     linewidth = 0.8,
                     colour = "black",
                     aes(x = row_ref, 
                         xend = row_ref, 
                         y = y_top_t$y, 
                         yend = y_top_t$yend,
                         colour = !!enquo_x),
                     lineend = "square")
    } else {
      raw_plot <- raw_plot +
        geom_segment(data = tufte_lines_df, linewidth = 0.8,
                     aes(x = row_ref, 
                         xend = row_ref, 
                         y = y_bot_t$y, 
                         yend = y_bot_t$yend,
                         colour = !!enquo_x),
                     lineend = "square") +
        geom_segment(data = tufte_lines_df, linewidth = 0.8,
                     aes(x = row_ref, 
                         xend = row_ref, 
                         y = y_top_t$y, 
                         yend = y_top_t$yend,
                         colour = !!enquo_x),
                     lineend = "square")
    }
  }
  
  # Remove x-axis and redraw depending on float_contrast
  if(isTRUE(float_contrast)) {
    raw_plot <- raw_plot +
      float_contrast_theme +
      geom_segment(linewidth = 0.8, 
                   color = "black",
                   aes(x = 0.6, xend = raw_x_max+0.5, y = raw_y_min, yend = raw_y_min))
    
  } else {
    # Obtain dfs for xaxis redraw
    dfs_for_xaxis_redraw <- create_dfs_for_xaxis_redraw(idx)
    df_for_line <- dfs_for_xaxis_redraw$df_for_line
    df_for_ticks <- dfs_for_xaxis_redraw$df_for_ticks
    
    raw_plot <- raw_plot +
      non_float_contrast_theme +
      # Redraw xaxis line
      geom_segment(data = df_for_line,
                   linewidth = 0.5,
                   lineend = "square", 
                   color = "black",
                   aes(x = x, 
                       xend = xend, 
                       y = raw_y_min + raw_y_mean/30, 
                       yend = raw_y_min + raw_y_mean/30))  +
      # Redraw xaxis ticks
      geom_segment(data = df_for_ticks,
                   linewidth = 0.5,
                   lineend = "square", 
                   color = "black",
                   aes(x = x, 
                       xend = x, 
                       y = raw_y_min + raw_y_mean/30, 
                       yend = raw_y_min))
  }
  
  # Add y_labels component
  if(isTRUE(proportional)){
    raw_plot <- raw_plot +
      labs(y = "proportion of success")
  } else {
    raw_plot <- raw_plot +
      labs(y = "value")
  }
  
  return(raw_plot)
}
```

# custom violin & boot_ci geoms
```{r}
draw_panel_halfviolin <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
  
  violin <- polygonGrob(x = coords$x,
                        y = coords$y,
                        gp = gpar(col = coords$col,
                                  fill = coords$fill,
                                  alpha = coords$alpha))

}

GeomHalfViolin <- ggproto("GeomHalfViolin", Geom,
                          required_aes = c("x", "y"),
                          default_aes = aes(col = "#ff800e", 
                                            fill = "#ff800e",
                                            alpha = 0.8),
                          draw_key = draw_key_point,
                          draw_panel = draw_panel_halfviolin)

geom_halfviolin <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomHalfViolin,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}

draw_panel_boot_ci <- function(data, panel_scales, coord) {
  coords <- coord$transform(data, panel_scales) 
        
  ci_line <- segmentsGrob(x0 = coords$x,
                          x1 = coords$x,
                          y0 = coords$ymin,
                          y1 = coords$ymax,
                          gp = gpar(lwd = coords$size * .pt,
                                    lineend = coords$lineend))
  
  ci_dot <- pointsGrob(x = coords$x,
                       y = coords$middle,
                       pch = coords$shape)
  
  gTree(children = gList(ci_line, ci_dot))

}

GeomBootCI <- ggproto("GeomBootCI", Geom,
                      required_aes = c("x", "ymin", "ymax", "middle"),
                      default_aes = aes(size = 1.2,
                                        shape = 19, 
                                        lwd = 2,
                                        lineend = "square"),
                      draw_key = draw_key_point,
                      draw_panel = draw_panel_boot_ci)

geom_bootci <- function(mapping = NULL, data = NULL, stat = "identity", 
                           position = "identity", show.legend = NA, 
                           na.rm = FALSE, inherit.aes = TRUE, ...) {
        layer(data = data, 
              mapping = mapping,
              stat = stat,
              geom = GeomBootCI,
              position = position,
              show.legend = show.legend,
              inherit.aes = inherit.aes,
              params = list(na.rm = na.rm, ...))
}
```

# delta_plot function 
```{r}
plot_delta <- function(dabest_effectsize_obj, float_contrast) {
  idx = dabest_effectsize_obj$idx
  bootstraps = dabest_effectsize_obj$bootstraps
  delta_x_labels = unlist(dabest_effectsize_obj$delta_x_labels)
  delta_y_labels = dabest_effectsize_obj$delta_y_labels
  delta_x_max = length(unlist(idx))
  float_contrast = float_contrast
  row_num = dabest_effectsize_obj$row_num
  raw_y_range_vector <- dabest_effectsize_obj$ylim
  control_summary <- dabest_effectsize_obj$control_summary
  test_summary <- dabest_effectsize_obj$test_summary
  
  # Extracting geom_bootci params
  ci_low = dabest_effectsize_obj$bca_ci_low
  ci_high = dabest_effectsize_obj$bca_ci_high
  difference = dabest_effectsize_obj$difference
  
  # Initialising ylim limits
  delta_y_max = .Machine$double.xmin
  delta_y_min = .Machine$double.xmax
  
  delta_plot <- ggplot()
  
  for(i in row_num){
    ci_coords <- density(bootstraps[[1]])
    x_coords_ci <- ci_coords$x
    y_coords_ci <- ci_coords$y
    
    # Standardise y
    y_coords_ci <- (y_coords_ci - min(y_coords_ci))/(max(y_coords_ci) - min(y_coords_ci))
    y_coords_ci <- y_coords_ci/4
    
    if(isTRUE(float_contrast)){
      y_coords_ci <- y_coords_ci*2 + i
    }else{
      y_coords_ci <- y_coords_ci + i
    }
    
    min_x_coords <- min(x_coords_ci)
    max_x_coords <- max(x_coords_ci)
    
    # Keeping track of ylim limits
    if(min_x_coords < delta_y_min){
      delta_y_min <- min_x_coords
    }
    if(max_x_coords > delta_y_max){
      delta_y_max <- max_x_coords
    }
    
    delta_plot <- delta_plot +
      geom_halfviolin(aes(x = y_coords_ci, y = x_coords_ci))
    
  }
  delta_plot <- delta_plot +
    geom_bootci(aes(x = row_num,
                    ymin = ci_low,
                    ymax = ci_high,
                    middle = difference))
  
  delta_y_mean <- (delta_y_max - delta_y_min)/2
  
  if(isTRUE(float_contrast)){
    # left-right graph
    # Calculate new ylims to align summary lines
    min_raw_y <- raw_y_range_vector[1]
    raw_y_range <- raw_y_range_vector[2] - raw_y_range_vector[1]
    min_y_coords <- difference/(1 - (test_summary - min_raw_y)/(control_summary - min_raw_y))
    delta_y_range <- raw_y_range * -min_y_coords/(control_summary - min_raw_y)
    
    delta_plot <- delta_plot +
      theme_classic() +
      
      # Draw summary lines
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 1.5, 
                       xend = 3, 
                       y = difference, 
                       yend = difference)) +
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 1.5, 
                       xend = 3, 
                       y = 0, 
                       yend = 0)) +
      
      # Extend x-axis & add labels
      scale_x_continuous(limits = c(1.5,3),
                         expand = c(0,0),
                         breaks = c(2),
                         labels = delta_x_labels[2]) +
      
      # Scale y-axis for alignment of summary lines & change position of y-axis to right
      scale_y_continuous(limits = c(min_y_coords, 
                                    min_y_coords + delta_y_range),
                         expand = c(0, 0),
                         position = "right") +
      float_contrast_theme +
      
      # Redraw x-axis line
      geom_hline(linewidth = 0.8,
                 yintercept = min_y_coords)
    
  } else {
    # top-down graph
    # Scale x-axis for alignment & add labels
    dfs_for_xaxis_redraw <- create_dfs_for_xaxis_redraw(idx)
    df_for_line <- dfs_for_xaxis_redraw$df_for_line
    df_for_ticks <- dfs_for_xaxis_redraw$df_for_ticks
    
    delta_plot <- delta_plot +
      theme_classic() +
      scale_x_continuous(limits = c(0.6,3),
                         expand = c(0,0),
                         breaks = c(1:delta_x_max),
                         labels = delta_x_labels) +
      non_float_contrast_theme +
      
      # Drawing of the 0 line
      geom_segment(colour = "black", 
                   linewidth = 0.3, 
                   aes(x = 0.8, 
                       xend = 3, 
                       y = 0, 
                       yend = 0)) +
      scale_y_continuous(limits = c(delta_y_min - delta_y_mean/10, 
                                    delta_y_max + delta_y_mean/10),
                         expand = c(0,0)) +
      
      # Redraw xaxis line
      geom_segment(data = df_for_line,
                   linewidth = 0.5,
                   lineend = "square", 
                   color = "black",
                   aes(x = x, 
                       xend = xend, 
                       y = delta_y_min - delta_y_mean/15, 
                       yend = delta_y_min - delta_y_mean/15))  +
      # Redraw xaxis ticks
      geom_segment(data = df_for_ticks,
                   linewidth = 0.5,
                   lineend = "square", 
                   color = "black",
                   aes(x = x, 
                       xend = x, 
                       y = delta_y_min - delta_y_mean/15, 
                       yend = delta_y_min - delta_y_mean/10))
  }
  
  delta_plot <- delta_plot +
    labs(y = delta_y_labels)
  
  return(delta_plot)
}
```

# dabest_plot functin
```{r}
dabest_plot <- function(dabest_obj.mean_diff, float_contrast = TRUE) {
  if (isFALSE(float_contrast)) {
    cowplot::plot_grid(
    plotlist   = list(plot_raw(dabest_obj.mean_diff, float_contrast=FALSE), 
                      plot_delta(dabest_obj.mean_diff, float_contrast=FALSE)),
    nrow       = 2,
    ncol       = 1,
    axis       = "lr",
    align      = "b")
  } else {
    cowplot::plot_grid(
    plotlist   = list(plot_raw(dabest_obj.mean_diff, float_contrast=TRUE), 
                      plot_delta(dabest_obj.mean_diff, float_contrast=TRUE)),
    nrow       = 1,
    ncol       = 2,
    rel_widths = c(0.7, 0.2),
    axis       = "lr",
    align      = "h")
  }
}
```

# Testing dataset
```{r}
set.seed(12345)

N = 40
c1 <- rnorm(N, mean = 100, sd = 25)
c2 <- rnorm(N, mean = 100, sd = 50)
g1 <- rnorm(N, mean = 120, sd = 25)
g2 <- rnorm(N, mean = 80, sd = 50)
g3 <- rnorm(N, mean = 100, sd = 12)
g4 <- rnorm(N, mean = 100, sd = 50)
gender <- c(rep('Male', N/2), rep('Female', N/2))
dummy <- rep("Dummy", N)
id <- 1: N

wide.data <- tibble::tibble(
  Control1 = c1, Control2 = c2,
  Group1 = g1, Group2 = g2, Group3 = g3, Group4 = g4,
  Dummy = dummy,
  Gender = gender, ID = id)

my.data <- wide.data %>%
  tidyr::gather(key = Group, value = Measurement, -ID, -Gender, -Dummy)
```


# Testing unpaired plots
```{r}
dabest_obj <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1"))
dabest_obj.mean_diff <- mean_diff(dabest_obj)
dabest_obj.hedges_g <- hedges_g(dabest_obj)
dabest_obj.median_diff <- median_diff(dabest_obj)

# alternative way of plotting is
# dabest_obj.mean_diff.plot <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1")) %>%
#   mean_diff() %>%
#   dabest_plot()
# 
# dabest_obj.mean_diff.plot
```

```{r}
dabest_plot(dabest_obj.mean_diff, TRUE)
dabest_plot(dabest_obj.mean_diff, FALSE)
```
# Testing paired plots 
```{r}
dabest_obj <- load(data = my.data, x = Group, y = Measurement, idx = c("Control1", "Group1"), is_paired = TRUE, id_col = ID)
dabest_obj.paired_mean_diff <- mean_diff(dabest_obj)
dabest_obj.paired_median_diff <- median_diff(dabest_obj)
```

```{r}
dabest_plot(dabest_obj.paired_median_diff, TRUE)
dabest_plot(dabest_obj.paired_median_diff, FALSE)
```

# Testing proportional dataset
```{r}
set.seed(12345)

N = 40

my.data.control_proportional <- data.frame(
  Group = sample(c("Control1"), 40, TRUE)
)
my.data.control_proportional$Success <- numeric(nrow(my.data.control_proportional))
my.data.control_proportional$Success[sample(nrow(my.data.control_proportional), 8)] <- 1

my.data.test_proportion <- data.frame(
  Group = sample(c("Test1"), 40, TRUE)
)
my.data.test_proportion$Success <- numeric(nrow(my.data.test_proportion))
my.data.test_proportion$Success[sample(nrow(my.data.test_proportion), 22)] <- 1

my.data.proportional <- rbind(my.data.control_proportional, my.data.test_proportion)
id <- data.frame(ID = rep(c(1:40), 2))
my.data.proportional <- cbind(my.data.proportional, id)
```

```{r}
dabest_obj_proportional.mean_diff <- load(data = my.data.proportional, 
                                  x = Group, 
                                  y = Success, 
                                  idx = c("Control1", "Test1"),
                                  proportional = TRUE) %>%
  mean_diff()
```

```{r}
dabest_plot(dabest_obj_proportional.mean_diff, TRUE) 
dabest_plot(dabest_obj_proportional.mean_diff, FALSE)
```

```{r}
dabest_obj_proportional.cohens_h <- load(data = my.data.proportional, 
                                  x = Group, 
                                  y = Success, 
                                  idx = c("Control1", "Test1"),
                                  proportional = TRUE) %>%
  cohens_h()
```

```{r}

dabest_plot(dabest_obj_proportional.cohens_h, TRUE)
dabest_plot(dabest_obj_proportional.cohens_h, FALSE)
```

```{r}
dabest_obj_sankey.mean_diff <- load(data = my.data.proportional, 
                                  x = Group, 
                                  y = Success, 
                                  idx = c("Control1", "Test1"),
                                  proportional = TRUE,
                                  is_paired = TRUE,
                                  id_col = ID) %>%
  mean_diff()
```

```{r}
dabest_plot(dabest_obj_sankey.mean_diff, TRUE)
dabest_plot(dabest_obj_sankey.mean_diff, FALSE)
```